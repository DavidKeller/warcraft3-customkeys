#!/usr/bin/env python3

import sys
import argparse
import locale
import configparser
import json
import logging
from collections import defaultdict
from glob import glob
from os import path

LOGGER = logging.getLogger(__name__)

NEW_ABILITY_POSITIONS = (
    '0,2', '1,2', '2,2', '3,2', # Fill bottom line
    '0,1', '1,1', '2,1', '3,1', # Fill middle line starting from second column
    '0,0', '1,0', '2,0', '3,0', # Fill top line
)

NEW_UNITS_POSITIONS = (
    '0,0', '1,0', '2,0', '3,0', # Fill top line
    '0,1', '1,1', '2,1', '3,1',  # Fill middle line starting from second column
    '0,2', '1,2', '2,2', '3,2',  # Fill bottom line
)

NEW_ITEMS_POSITIONS = (
    '0,0', '1,0', '2,0', '3,0', # Fill top line
    '0,1', '1,1', '2,1', '3,1',  # Fill middle line starting from second column
    '0,2', '1,2', '2,2', '3,2',  # Fill bottom line
)

class Ability:
    def __init__(self):
        self.conflict = False
        self.default_pos = None
        self.forced_pos = False
        self.user_ids = list()
        self.position_matrix = None

class Skin:
    def __init__(self):
        self.used_slots = list()
        self.abilities = list()
        self.position_matrix = None

def _parse_file(pattern):
    store = configparser.ConfigParser(comment_prefixes=('//'),
                                      delimiters=('='),
                                      interpolation=None,
                                      strict=False)
    for filepath in glob(pattern):
        LOGGER.debug('Parsing %s', filepath)
        with open(filepath, 'r', encoding='utf-8-sig') as f:
            store.read_file(f)

    return store

class StringsStore:
    def __init__(self, unitsdir):
        self._store = _parse_file(path.join(unitsdir, '*strings.txt'))

    def get_name(self, item_id):
        name = self._store.get(item_id, 'Name', fallback=None)
        if name is None:
            return '"{}"'.format(item_id)

        return '"{}" ({})'.format(item_id, name)

    def get_hotkey(self, item_id):
        return self._store.get(item_id, 'Hotkey', fallback=None)

class FuncStore:
    def __init__(self, unitsdir):
        self._store = _parse_file(path.join(unitsdir, '*func.txt'))

    def get_position(self, item_id):
        return self._store.get(item_id, 'Buttonpos', fallback=None)

    def get_units(self, item_id):
        return self._store.get(item_id, 'Sellunits', fallback=None)

    def get_items(self, item_id):
        return (self._store.get(item_id, 'Sellitems', fallback=None) or
                self._store.get(item_id, 'Makeitems', fallback=None))

def main():
    parser = argparse.ArgumentParser(description='Check Warcraft Reforged key positions')
    parser.add_argument('--verbose', action='store_true', help='Enable verbose loggng')
    parser.add_argument('unitsdir', type=str, help='The Warcraft Reforged units/ directory')
    parser.add_argument('override', type=argparse.FileType('w'), help='The generated override file')

    args = parser.parse_args()

    if args.verbose:
        log_level = logging.DEBUG
    else:
        log_level = logging.INFO
    logging.basicConfig(level=log_level)

    LOGGER.info('Parsing strings')
    strings_store = StringsStore(args.unitsdir)

    LOGGER.info('Parsing func')
    func_store = FuncStore(args.unitsdir)

    LOGGER.info('Parsing skin')
    skin_store = _parse_file(path.join(args.unitsdir, '*skin.txt'))

    abilities = defaultdict(Ability)
    skins = defaultdict(Skin)

    LOGGER.info('Checking coherency..')
    for skin_id, skin_attr in skin_store.items():
        LOGGER.debug('Considering %s',
                     strings_store.get_name(skin_id))

        # Consider only skins with abilities
        heroabils = skin_attr.get('heroabilskinlist')
        abils = skin_attr.get('abilskinlist')
        items = func_store.get_items(skin_id)
        units = func_store.get_units(skin_id)

        if heroabils is None and abils is None and items is None and units is None:
            LOGGER.debug('Skipping "%s"', skin_id)
            continue

        skin = skins[skin_id]
        ability_ids = list()
        if items is not None:
            ability_ids += items.split(',')
            skin.position_matrix = NEW_ITEMS_POSITIONS
            LOGGER.debug('%s considered as a shop',
                         strings_store.get_name(skin_id))
        if units is not None:
            ability_ids += units.split(',')
            skin.position_matrix = NEW_UNITS_POSITIONS
            LOGGER.debug('%s considered as a units building',
                         strings_store.get_name(skin_id))
        if abils is not None:
            ability_ids += abils.split(',')
            skin.position_matrix = NEW_ABILITY_POSITIONS
            LOGGER.debug('%s considered as a unit',
                         strings_store.get_name(skin_id))
        if heroabils is not None:
            ability_ids += heroabils.split(',')
            skin.position_matrix = NEW_ABILITY_POSITIONS
            LOGGER.debug('%s considered as a hero',
                         strings_store.get_name(skin_id))

        skin_abilities = skin.abilities
        skin_abilities_pos = list()
        # Retrieve the abilities with an assigned button position
        # And associated the current unit with its abilities
        for ability_id in ability_ids:
            LOGGER.debug('Found ability %s',
                         strings_store.get_name(ability_id))

            ability_pos = func_store.get_position(ability_id)
            if ability_pos is None:
                # Some abilities may miss position but are still intended
                # to be clicked
                if strings_store.get_hotkey(ability_id) is not None:
                    LOGGER.warn('Add default position to ability %s',
                                strings_store.get_name(ability_id))
                    ability_pos = '0,0'
                else:
                    continue

            LOGGER.debug('At position "%s"', ability_pos)
            ability = abilities[ability_id]
            ability.user_ids.append(skin_id)
            if heroabils is not None:
                ability.forced_pos = True
            if ability.position_matrix is None:
                LOGGER.debug('Attaching user %s position matrix to ability %s',
                             skin_id, ability_id)
                ability.position_matrix = skin.position_matrix
                ability.default_pos = skin.position_matrix.index(ability_pos)
            else:
                if ability.position_matrix is not skin.position_matrix:
                    raise Exception('Ability used with different matrices')
            skin_abilities.append(ability_id)
            skin_abilities_pos.append(ability_pos)

        # Check if some abilities have the same position
        if len(set(skin_abilities_pos)) == len(skin_abilities_pos):
            LOGGER.debug('No conflict detected')
            continue

        # Mark all the unit abilities as conflicted
        for ability_id in skin_abilities:
            abilities[ability_id].conflict = True

        # Dump the unit abilities
        LOGGER.warn('Abilities conflicts on %s',
                    strings_store.get_name(skin_id))

    LOGGER.info('Solving..')

    new_mappings = dict()

    # Add all abilities of users of at least one conflicted ability
    # even if there it is not conflicting on them
    for ability_id, ability in list(abilities.items()):
        if not ability.conflict:
            continue

        for user_id in ability.user_ids:
            for user_ability_id in skins[user_id].abilities:
                LOGGER.debug('Marking %s as conflicted',
                             strings_store.get_name(user_ability_id))
                abilities[user_ability_id].conflict = True

    # Some abilities may not change position (e.g. heros)
    for ability_id, ability in abilities.items():
        if not ability.forced_pos:
            continue

        # Flag the abilty's user slots as used
        for skin_id in ability.user_ids:
            skin = skins[skin_id]
            skin.used_slots.append(ability.default_pos)

    # Sort the abilities to place mostly used first
    for ability_id, ability in sorted(abilities.items(),
                                      key=lambda x: len(x[1].user_ids),
                                      reverse=True):
        if not ability.conflict or ability.forced_pos is not None:
            continue

        LOGGER.debug('Placing %s', strings_store.get_name(ability_id))
        # For each possible position
        for pos in [ability.default_pos] + range(len(NEW_ABILITY_POSITIONS)).remove(ability.default_pos):
            # Check if it is free for related units
            for skin_id in ability.user_ids:
                LOGGER.debug('Considering user %s slot %d',
                             strings_store.get_name(skin_id), pos)
                if pos in skins[skin_id].used_slots:
                    # Conflict detected
                    break
            else:
                # Flag the abilty's user slots as used
                for skin_id in ability.user_ids:
                    skins[skin_id].used_slots.append(pos)

                new_position = NEW_ABILITY_POSITIONS[pos]
                LOGGER.info('Assigned %s to position %s',
                            strings_store.get_name(ability_id), new_position)
                # Save the ability mapping
                new_mappings[ability_id] = [int(p) for p in new_position.split(',')]

                break
        else:
            LOGGER.error('Failed to map %s on "%s"',
                         strings_store.get_name(ability_id), ability.user_id)
            sys.exit(1)

    LOGGER.info('Generating updated mapping.')
    args.override.write(json.dumps(new_mappings))


if __name__ == '__main__':
    locale.setlocale(locale.LC_ALL, '')
    main()
