#!/usr/bin/env python3

import sys
import argparse
import locale
import configparser
import json
import logging
from collections import defaultdict
from glob import glob
from os import path

LOGGER = logging.getLogger(__name__)

NEW_POSITIONS = (
    (0, 2), (1, 2), (2, 2), (3, 2), # Fill bottom line
    (1,1), (2, 1)  # Fill middle line starting from second column
)

class Ability:
    def __init__(self):
        self.conflict = False
        self.user_ids = list()

def _parse_file(pattern):
    store = configparser.ConfigParser(comment_prefixes=('//'),
                                      delimiters=('='),
                                      interpolation=None,
                                      strict=False)
    for filepath in glob(pattern):
        LOGGER.debug('Parsing %s', filepath)
        with open(filepath, 'r', encoding='utf-8-sig') as f:
            store.read_file(f)

    return store

class StringsStore:
    def __init__(self, unitsdir):
        self._store = _parse_file(path.join(unitsdir, '*strings.txt'))

    def get_name(self, item_id):
        return self._store.get(item_id, 'Name', fallback=None)

    def get_hotkey(self, item_id):
        return self._store.get(item_id, 'Hotkey', fallback=None)

class FuncStore:
    def __init__(self, unitsdir):
        self._store = _parse_file(path.join(unitsdir, '*func.txt'))

    def get_position(self, item_id):
        return self._store.get(item_id, 'Buttonpos', fallback=None)

    def get_items(self, item_id):
        return self._store.get(item_id, 'Sellunits', fallback=None)

def main():
    parser = argparse.ArgumentParser(description='Check Warcraft Reforged key positions')
    parser.add_argument('--verbose', action='store_true', help='Enable verbose loggng')
    parser.add_argument('unitsdir', type=str, help='The Warcraft Reforged units/ directory')
    parser.add_argument('override', type=argparse.FileType('w'), help='The generated override file')

    args = parser.parse_args()

    if args.verbose:
        log_level = logging.DEBUG
    else:
        log_level = logging.INFO
    logging.basicConfig(level=log_level)

    LOGGER.info('Parsing strings')
    strings_store = StringsStore(args.unitsdir)

    LOGGER.info('Parsing func')
    func_store = FuncStore(args.unitsdir)

    LOGGER.info('Parsing skin')
    skin_store = _parse_file(path.join(args.unitsdir, '*skin.txt'))

    abilities = defaultdict(Ability)
    skins_abilities = dict()

    LOGGER.info('Checking coherency..')
    for skin_id, skin_attr in skin_store.items():
        LOGGER.debug('Considering "%s" (%s)',
                     skin_id, strings_store.get_name(skin_id))

        # Consider only skins with abilities
        ability_ids = (skin_attr.get('heroabilskinlist') or
                       skin_attr.get('abilskinlist') or
                       func_store.get_items(skin_id))
        if ability_ids is None:
            LOGGER.debug('Skipping "%s"', skin_id)
            continue

        skins_abilities[skin_id] = skin_abilities = list()
        skin_abilities_pos = list()
        # Retrieve the abilities with an assigned button position
        # And associated the current unit with its abilities
        for ability_id in ability_ids.split(','):
            LOGGER.debug('Found ability "%s" (%s)',
                         ability_id, strings_store.get_name(ability_id))

            ability_pos = func_store.get_position(ability_id)
            if ability_pos is None:
                 # Some abilities may miss position but still intended
                # to be clicked
                if strings_store.get_hotkey(ability_id) is not None:
                    LOGGER.warn('Add default position to ability "%s" (%s)',
                                ability_id,
                                strings_store.get_name(ability_id))
                    ability_pos = '0,0'
                else:
                    continue

            LOGGER.debug('At position "%s"', ability_pos)
            abilities[ability_id].user_ids.append(skin_id)
            skin_abilities.append(ability_id)
            skin_abilities_pos.append(ability_pos)

        # Check if some abilities have the same position
        if len(set(skin_abilities_pos)) == len(skin_abilities_pos):
            LOGGER.debug('No conflict detected')
            continue

        # Mark all the unit abilities as conflicted
        for ability_id in skin_abilities:
            abilities[ability_id].conflict = True

        # Dump the unit abilities
        LOGGER.warn('Abilities conflicts on "%s" (%s)',
                    skin_id, strings_store.get_name(skin_id))

    LOGGER.info('Solving..')

    new_mappings = dict()
    skin_used_slots = defaultdict(list)

    # Add all abilities of users of at least one conflicted ability
    # even if there it is not conflicting on them
    for ability_id, ability in list(abilities.items()):
        if not ability.conflict:
            continue

        for user_id in ability.user_ids:
            for user_ability_id in skins_abilities[user_id]:
                LOGGER.debug('Marking "%s" (%s) as conflicted',
                             user_ability_id,
                             strings_store.get_name(user_ability_id))
                abilities[user_ability_id].conflict = True

    conflicted_abilities = [a for a in abilities.items() if a[1].conflict]

    # Sort the abilities to place mostly used first
    for ability_id, ability in sorted(conflicted_abilities,
                                      key=lambda x: len(x[1].user_ids),
                                      reverse=True):

        LOGGER.debug('Placing "%s" (%s)',
                     ability_id, strings_store.get_name(ability_id))
        # For each possible position
        for pos in range(len(NEW_POSITIONS)):
            # Check if it is free for related units
            for skin_id in ability.user_ids:
                LOGGER.debug('Considering user "%s" (%s) slot %d',
                             skin_id, strings_store.get_name(skin_id), pos)
                if pos in skin_used_slots[skin_id]:
                    # Conflict detected
                    break
            else:
                # Flag the abilty's user slots as used
                for skin_id in ability.user_ids:
                    skin_used_slots[skin_id].append(pos)

                new_position = NEW_POSITIONS[pos]
                LOGGER.info('Assigned "%s" (%s) to position %s',
                            ability_id, strings_store.get_name(ability_id),
                            new_position)
                # Save the ability mapping
                new_mappings[ability_id] = new_position

                break
        else:
            LOGGER.error('Failed to map "%s" on "%s"', ability_id, ability.user_id)
            sys.exit(1)

    LOGGER.info('Generating updated mapping.')
    args.override.write(json.dumps(new_mappings))


if __name__ == '__main__':
    locale.setlocale(locale.LC_ALL, '')
    main()
