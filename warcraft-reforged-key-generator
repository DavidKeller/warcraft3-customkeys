#!/usr/bin/env python3

import sys
import argparse
import locale
import configparser
import json
import logging
import re
from enum import Enum
from collections import defaultdict
from glob import glob
from os import path

LOGGER = logging.getLogger(__name__)

BUILDING_POSITIONS = (
    '0,0', '1,0', '2,0', '3,0', # Fill top line
    '0,1', '1,1', '2,1', '3,1', # Fill middle line starting from second column
    '0,2', '1,2', '2,2', '3,2', # Fill bottom line
)

ABILITY_POSITIONS = (
    '0,2', '1,2', '2,2', '3,2', # Fill bottom line
    '0,1', '1,1', '2,1', '3,1', # Fill middle line starting from second column
    '0,0', '1,0', '2,0', '3,0', # Fill top line
)

KEYS = (
    ( 'A', 'Z', 'E', 'R' ),
    ( 'Q', 'S', 'D', 'F' ),
    ( 'W', 'X', 'C', 'V' ),
)

class Cell:
    def __init__(self):
        self.id = None
        self.name = None
        self.position_matrix = None
        self.default_position = None
        self.un_position = None
        self.research_position = None
        self.requires_count = None
        self.is_visible = True
        self.owner_cells = set()
        self.owned_cells = set()
        self.used_slots = set()

def _parse_file(datadirs):
    store = configparser.ConfigParser(comment_prefixes=('//'),
                                      delimiters=('='),
                                      interpolation=None,
                                      strict=False)
    for datadir in datadirs:
        for filepath in glob(path.join(datadir, '*.txt')):
            LOGGER.debug('Parsing %s', filepath)
            with open(filepath, 'r', encoding='utf-8-sig') as f:
                store.read_file(f)

    return store

def _write_entry(f, prefix, position, count):
    x = position[0]
    y = position[1]

    entry = (prefix + 'buttonpos').title()
    f.write('{}={},{}\n'.format(entry, x, y))

    entry = (prefix + 'hotkey').title()
    f.write('{}={}\n'.format(entry, ','.join(KEYS[y][x] * count)))
   
class Section:
    def __init__(self, id, comment):
        self._id = id
        self._comment = comment
        self.position = None
        self.unposition = None
        self.research = None
        self.require = None

    def dump(self, f):
        if self._comment:
            f.write('// {}\n'.format(self._comment))

        f.write('[{}]\n'.format(self._id))

        count = self.require or 1

        _write_entry(f, '', self.position, count)

        if self.unposition is not None:
            _write_entry(f, 'un', self.unposition, count)

        if self.research is not None:
            _write_entry(f, 'research', self.research, count)

        f.write('\n')
        

class Generator:
    def __init__(self, args):
        LOGGER.info('Parsing')
        self._store = _parse_file(args.datadirs)

        self._cells = defaultdict(Cell)
        self._conflicted_cells = set()

        self._overridesfile = args.overridesfile
        self._customkey_file = args.customkeyfile

    def run(self):
        LOGGER.info('Discovering..')
        for skin_id, skin_attr in self._store.items():
            self._discover_skin(skin_id, skin_attr)

        LOGGER.info('Patching dependencies..')
        self._add_overrides()

        LOGGER.info('Mapping parents with children..')
        self._map_owned_cells()

        LOGGER.info('Detecting conflicts..')
        for cell in self._cells.values():
            self._detect_conflicts(cell)

        LOGGER.info('Solving conflicts..')
        new_mappings = self._solve()
        self._generate_custom_key(new_mappings)

    def _discover_skin(self, skin_id, skin_attr):
        skin_name = skin_attr.get('name')
        if skin_name is None:
            skin_name = '"{}"'.format(skin_id)
        else:
            skin_name = '"{}" ({})'.format(skin_id, skin_name)
        LOGGER.debug('Considering %s', skin_name)

        cell = self._cells[skin_id]
        cell.id = skin_id
        cell.name = skin_name
        cell.un_position = skin_attr.get('unbuttonpos')
        cell.research_position = skin_attr.get('researchbuttonpos')
        cell.requires_count = skin_attr.get('requirescount')

        if skin_attr.get('armor') in ['Wood', 'Stone']:
            LOGGER.debug('%s considered as an item/building', skin_name)
            cell.position_matrix = BUILDING_POSITIONS
        else:
            LOGGER.debug('%s considered as other', skin_name)
            cell.position_matrix = ABILITY_POSITIONS

        position = skin_attr.get('buttonpos')
        hotkey = skin_attr.get('hotkey')

        LOGGER.debug('Hotkey %s and position %s', hotkey, position)
        if position is None and hotkey is None:
            cell.is_visible = False
        elif position is None:
            cell.default_position = cell.position_matrix[0]
            LOGGER.warn('Add default position %s to cell %s',
                        cell.default_position, skin_name)
        else:
            cell.default_position = position

        # Retrieve the owned cells (can be any type of skin)
        heroabils = skin_attr.get('heroabilskinlist')
        abils = skin_attr.get('abilskinlist')
        items = skin_attr.get('sellitems') or skin_attr.get('makeitems')
        units = skin_attr.get('sellunits') or skin_attr.get('trains')
        researchs = skin_attr.get('researches')

        if abils is not None:
            cell.owned_cells |= set(abils.split(','))
        if heroabils is not None:
            cell.owned_cells |= set(heroabils.split(','))
        if units is not None:
            cell.owned_cells |= set(units.split(','))
        if items is not None:
            cell.owned_cells |= set(items.split(','))
        if researchs is not None:
            cell.owned_cells |= set(researchs.split(','))

    def _add_overrides(self):
        if self._overridesfile is None:
            return

        overrides = json.load(self._overridesfile)

        dependencies = overrides.get('dependencies', dict())
        anti_dependencies = overrides.get('anti_dependencies', dict())
        positions = overrides.get('positions', dict())

        for cell in self._cells.values():
            manual_dependencies = dependencies.get(cell.id)
            if manual_dependencies is not None:
                cell.owned_cells |= set(manual_dependencies)

            manual_anti_dependencies = anti_dependencies.get(cell.id)
            if manual_anti_dependencies is not None:
                cell.owned_cells -= set(manual_anti_dependencies)

            manual_position = positions.get(cell.id)
            if manual_position is not None:
                cell.default_position = manual_position

    def _map_owned_cells(self):
        for cell in self._cells.values():
            LOGGER.debug('Mapping owned cell of %s', cell.name)

            new_owned_cells = list()
            for owned_cell_id in set(cell.owned_cells):
                owned_cell = self._cells.get(owned_cell_id)
                if owned_cell is None or owned_cell.is_visible is False:
                    continue
                    
                LOGGER.debug('Found owned %s', owned_cell.name)
                new_owned_cells.append(owned_cell)
                owned_cell.owner_cells.add(cell)

            cell.owned_cells = new_owned_cells
        
    def _detect_conflicts(self, cell):
        LOGGER.debug('Checking cell %s for direct conflicts', cell.name)
        
        # Retrieve the cells with an assigned button position
        # And associated the current unit with its cells
        grid_cells_pos = list()
        for owned_cell in cell.owned_cells:
            LOGGER.debug('Looking owned cell %s at position "%s"',
                         owned_cell.name, owned_cell.default_position)

            grid_cells_pos.append(owned_cell.default_position)

        # Check if some cells have the same position
        if len(set(grid_cells_pos)) == len(grid_cells_pos):
            LOGGER.debug('No conflict detected')
            return

        LOGGER.warn('cells conflicts on %s', cell.name)

        for owned_cell in cell.owned_cells:
            # For each owner of the current conflicted cell
            for owner_cell in owned_cell.owner_cells:
                # Flag all its cells as conflicted
                for sibbling_cell in owner_cell.owned_cells:
                    LOGGER.debug('Marking %s as conflicted',
                                 sibbling_cell.name)
                    self._conflicted_cells.add(sibbling_cell)

    def _solve(self):
        LOGGER.info('Solving conflicts..')

        new_mappings = dict()

        # Sort the cells to place mostly used first
        for cell in sorted(self._conflicted_cells,
                           key=lambda x: len(x.owner_cells),
                           reverse=True):
            LOGGER.debug('Placing %s', cell.name)

            # For each possible position
            possible_positions = [cell.position_matrix.index(cell.default_position)]
            for i in range(len(cell.position_matrix)):
                if i != cell.default_position:
                     possible_positions.append(i)
           
            for candidate in possible_positions:
                # Check if it is free for related units
                for owner_cell in cell.owner_cells:
                    LOGGER.debug('Considering user %s slot %s',
                                 owner_cell.name, candidate)
                    if candidate in owner_cell.used_slots:
                        # Conflict detected
                        break
                else:
                    # Flag the abilty's user slots as used
                    for owner_cell in cell.owner_cells:
                        owner_cell.used_slots.add(candidate)

                    new_position = cell.position_matrix[candidate]
                    LOGGER.info('Assigned %s to position %s',
                                cell.name, new_position)
                    # Save the cell mapping
                    new_mappings[cell.id] = [int(p) for p in new_position.split(',')]

                    break
            else:
                LOGGER.error('Failed to map %s on "%s"',
                             cell_id.name, cell.owner_cells)
                sys.exit(1)

        return new_mappings

    def _generate_custom_key(self, new_mappings):
        for cell_id, cell in self._cells.items():
            if cell.is_visible is False:
                continue

            LOGGER.debug('Writing %s section', cell.name)
            section = Section(cell.id, cell.name)

            override = new_mappings.get(cell.id)

            if override is None:
                section.position = [int(p) for p in cell.default_position.split(',')]
            else:
                section.position = override

            if cell.un_position is not None:
                if override is None:
                    section.unposition = [int(p) for p in cell.un_position.split(',')]
                else:
                    section.unposition = override

            if cell.research_position is not None:
                section.research = [int(p) for p in cell.research_position.split(',')]

            if cell.requires_count is not None:
                section.require = int(cell.requires_count)

            section.dump(self._customkey_file)

def main():
    parser = argparse.ArgumentParser(description='Check Warcraft Reforged key positions')
    parser.add_argument('--verbose', action='store_true', help='Enable verbose loggng')
    parser.add_argument('--overridesfile', type=argparse.FileType('r'), help=r'Manual overrides json file')
    parser.add_argument('--customkeyfile', type=argparse.FileType('w'), required=True, help=r'The CustomKeys.txt file to write')
    parser.add_argument('datadirs', type=str, nargs='+', help=r'The Warcraft Reforged war3.w3mod\units directory')

    args = parser.parse_args()

    if args.verbose:
        log_level = logging.DEBUG
    else:
        log_level = logging.INFO
    logging.basicConfig(level=log_level)

    Generator(args).run()

if __name__ == '__main__':
    locale.setlocale(locale.LC_ALL, '')
    main()
