import configparser
import logging
import re
from glob import glob
from os import path
from collections import defaultdict

LOGGER = logging.getLogger(__name__)

def parse_ini_file(f):
    doc = configparser.ConfigParser(comment_prefixes=('//'),
                                    delimiters=('='),
                                    interpolation=None,
                                    strict=False)

    doc.read_file(f)

    return doc

def parse_ini_files(datadirs, pattern='*.txt'):
    doc = configparser.ConfigParser(comment_prefixes=('//'),
                                    delimiters=('='),
                                    interpolation=None,
                                    strict=False)
    for datadir in datadirs:
        for filepath in glob(path.join(datadir, pattern)):
            LOGGER.debug('Parsing %s', filepath)
            with open(filepath, 'r', encoding='utf-8-sig') as f:
                doc.read_file(f)

    return doc

ID_RE = re.compile(r'ID;([^;]+)')
BOUNDARIES_RE = re.compile(r'B;X(\d+);Y(\d+)')
CONTENT_RE = re.compile(r'C;X(\d+);(?:Y(\d+);)?K(.+)')

def _parse_slk_file(f):
    match = ID_RE.match(f.readline())
    if match is None:
        raise Exception('Expected ID record')
    LOGGER.debug('File generated by %s', match.group(1))

    match = BOUNDARIES_RE.match(f.readline())
    if match is None:
        raise Exception('Expected B record')

    doc = list()
    current_line = list()

    last_y = '1'
    for line in f:
        match = CONTENT_RE.match(line)
        if match is None:
            continue

        new_y = match.group(2) or last_y
        if new_y != last_y:
            last_y = new_y
            doc.append(current_line)
            current_line = list()

        cell = (int(match.group(1)) - 1, match.group(3).strip('"'))
        current_line.append(cell)

    doc.append(current_line)
    return doc

def _update_slk_dict(doc, slk_doc):
    headers = {i:v for i, v in slk_doc[0]}
    LOGGER.debug('Slk headers %s', headers)
    for line_cells in slk_doc[1:]:
        line_id = line_cells[0][1]
        try:
            doc[line_id].update({headers.get(i, '?'): v for i, v in line_cells})
        except:
            LOGGER.error('Failing line %s, %d/%d', line_cells, len(headers), len(line_cells))
            raise

def parse_slk_files(datadirs, pattern='*.txt'):
    doc = defaultdict(dict)

    for datadir in datadirs:
        for filepath in glob(path.join(datadir, 'unit*.slk')):
            LOGGER.debug('Parsing %s', filepath)
            with open(filepath, 'r', encoding='utf-8-sig') as f:
                _update_slk_dict(doc, _parse_slk_file(f))

    return doc